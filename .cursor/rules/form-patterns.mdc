---
description: Guide for choosing between Server Actions vs Direct Services in forms and operations
globs:
  ['src/app/**/*', 'src/components/**/*', 'src/hooks/**/*', 'src/services/**/*']
alwaysApply: false
---

# Form Implementation Patterns

## Decision Framework for Forms and Operations

### ‚úÖ USE SERVER ACTIONS FOR:

- **CRUD operations** (create, edit, delete entities)
- **Authentication forms** (login, signup, password)
- **Single-step forms** with Zod validation
- **Operations NOT using TanStack Query for data fetching**

**Pattern:** `useActionState + FormData + Zod validation`

### ‚úÖ USE TANSTACK QUERY MUTATIONS FOR:

- **Status updates in data tables** (ACTIVE ‚Üí SUSPENDED)
- **Operations on entities already using TanStack Query**
- **Multi-step complex forms** (like CompletePlayaSetupModal)
- **Search/autocomplete functionality**
- **Operations requiring optimistic updates**
- **Complex conditional logic** or multiple validation steps
- **Fine-grained UI state control**

**Pattern:** `useMutation + queryClient.invalidateQueries`

### ‚úÖ USE TANSTACK QUERY (useQuery) FOR DATA FETCHING:

- **Reading data in Client Components** (lists, details, tables)
- **Real-time data updates** with automatic refetching
- **Client-side caching** and state management
- **Paginated or filtered lists**

**Pattern:** `useQuery + Server Action wrapper (queries.ts)`

**‚ö†Ô∏è CRITICAL:** Services using `createClient()` from `@/lib/supabase/server` CANNOT be called directly from Client Components because they import `next/headers`. You MUST create a Server Action wrapper.

## üéØ Consistency Rules:

- Similar operations should use the same pattern
- Deletions should match creation patterns (migrate to Server Actions)
- Status updates should be consistent across entities
- Follow existing patterns in the codebase

## üìã Decision Checklist:

1. **Are you READING data in a Client Component?** ‚Üí **TanStack Query (useQuery) + Server Action wrapper**
2. Is the data already managed by TanStack Query? ‚Üí **TanStack Query Mutation**
3. Is it a status update in a data table? ‚Üí **TanStack Query Mutation**
4. Is it a basic CRUD form (create/edit)? ‚Üí **Server Action**
5. Does it need multiple steps/validations? ‚Üí **TanStack Query Mutation**
6. Is it similar to existing operations? ‚Üí **Use same pattern**
7. Is Zod validation sufficient and no TanStack Query? ‚Üí **Server Action**

## Server Action Template:

```typescript
// actions.ts
'use server'

import { revalidatePath } from 'next/cache'

import { createEntitySchema } from '@/schemas/entity'
import { createEntity } from '@/services/entities'

type FormState = {
  success: boolean
  fields?: Record<string, string>
  errors?: Record<string, string[]>
}

export async function createEntityAction(
  prevState: FormState,
  payload: FormData
): Promise<FormState> {
  if (!(payload instanceof FormData)) {
    return {
      success: false,
      errors: { error: ['Datos de formulario inv√°lidos'] }
    }
  }

  const formData = Object.fromEntries(payload)
  const parsed = createEntitySchema.safeParse(formData)

  if (!parsed.success) {
    const errors = parsed.error.flatten().fieldErrors
    const fields: Record<string, string> = {}

    for (const key of Object.keys(formData)) {
      fields[key] = formData[key].toString()
    }

    return {
      success: false,
      fields,
      errors
    }
  }

  const result = await createEntity(parsed.data)

  if (result.error) {
    return {
      success: false,
      errors: { general: [result.error] }
    }
  }

  // ‚ö†Ô∏è CRITICAL: Always include revalidatePath for immediate UI refresh
  revalidatePath('/admin/entities')

  return { success: true }
}

// Component
'use client'

import { startTransition, useActionState, useEffect, useRef } from 'react'
import { useForm } from 'react-hook-form'
import { useRouter } from 'next/navigation'
import { zodResolver } from '@hookform/resolvers/zod'
import { toast } from 'sonner'

import { createEntityAction } from './actions'

export function CreateEntityForm() {
  const [formState, formAction, pending] = useActionState(createEntityAction, {
    success: false
  })
  const router = useRouter()
  const formRef = useRef<HTMLFormElement>(null)
  const processedSuccessRef = useRef(false)

  const form = useForm({
    resolver: zodResolver(createEntitySchema),
    mode: 'onChange'
  })

  const { control, handleSubmit } = form

  useEffect(() => {
    if (formState.success && !processedSuccessRef.current) {
      processedSuccessRef.current = true
      toast.success('Entity created successfully')
      router.push('/admin/entities')
    } else if (formState.errors) {
      Object.entries(formState.errors).forEach(([field, errors]) => {
        if (field === 'general') {
          toast.error('Error creating entity', {
            description: errors.join(', ')
          })
        }
      })
    }
  }, [formState.success, formState.errors, router])

  return (
    <form
      ref={formRef}
      action={formAction}
      onSubmit={(evt) => {
        evt.preventDefault()
        handleSubmit(() => {
          startTransition(() => {
            formAction(new FormData(formRef.current!))
          })
        })(evt)
      }}
    >
      {/* Form fields */}
      <button type="submit" disabled={pending}>
        {pending ? 'Creating...' : 'Create'}
      </button>
    </form>
  )
}
```

## TanStack Query Mutation Template:

```typescript
// hooks/mutations/entities.tsx
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { updateEntityStatus } from '@/services/entities'

export const useUpdateEntityStatus = () => {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (params: UpdateEntityStatusParams) => {
      const result = await updateEntityStatus(params)

      if (result.error) {
        throw new Error(result.error)
      }

      return result
    },
    onSuccess: () => {
      // Invalidate related queries to update UI
      queryClient.invalidateQueries({
        queryKey: ['entities']
      })
    }
  })
}

// Component
const updateStatusMutation = useUpdateEntityStatus()

const handleStatusChange = async (newStatus: string) => {
  try {
    await updateStatusMutation.mutateAsync({
      entityId: entity.id,
      status: newStatus
    })
    return { success: true, message: 'Status updated successfully' }
  } catch (error) {
    const errorMessage =
      error instanceof Error
        ? error.message
        : 'Unexpected error updating status'
    return { success: false, message: errorMessage }
  }
}
```

## TanStack Query (useQuery) Data Fetching Template:

```typescript
// app/admin/entities/queries.ts
'use server'

import { getEntities } from '@/services/entities'
import type { GetEntitiesParams } from '@/services/entities/types'

export async function getEntitiesAction(params?: GetEntitiesParams) {
  return await getEntities(params)
}

export async function getEntityByIdAction(id: string) {
  return await getEntityById(id)
}
```

```typescript
// hooks/queries/entities/getEntities.tsx
'use client'

import { useQuery } from '@tanstack/react-query'

import { getEntitiesAction } from '@/app/admin/entities/queries'
import type { Entity } from '@/services/entities'
import type { ApiResponse } from '@/types/api'

export function useGetEntities(params?: GetEntitiesParams) {
  return useQuery<ApiResponse<Entity[]>>({
    queryKey: ['entities', params],
    queryFn: async () => {
      return await getEntitiesAction(params)
    },
    staleTime: 30 * 1000 // 30 seconds
  })
}
```

```typescript
// Component
'use client'

import { useGetEntities } from '@/hooks/queries/entities/getEntities'

export function EntitiesList() {
  const { data, isLoading, error } = useGetEntities({
    page: 1,
    limit: 20
  })

  if (isLoading) return <Spinner />
  if (error) return <ErrorMessage />

  return (
    <div>
      {data?.data?.map((entity) => (
        <EntityCard key={entity.id} entity={entity} />
      ))}
    </div>
  )
}
```

**Key Points:**

- `queries.ts` acts as a Server Action wrapper for services
- Located in the same `/app` directory as the feature (e.g., `/app/admin/entities/queries.ts`)
- Named with `Action` suffix to distinguish from service functions
- Enables Client Components to fetch data from Server-only services
- Required when services use `createClient()` from `@/lib/supabase/server`

## Direct Service Template (Legacy):

```typescript
// service.ts
export async function operationEntity(
  data: EntityData
): Promise<ApiResponse<Entity>> {
  // service logic
}

// Component
const handleSubmit = async (data: EntityData) => {
  setIsLoading(true)
  try {
    const result = await operationEntity(data)
    if (result.error) {
      toast.error(result.error)
      return
    }
    toast.success('Operation successful')
  } catch (error) {
    toast.error('Unexpected error')
  } finally {
    setIsLoading(false)
  }
}
```

## üìÇ File Organization:

```
app/admin/entities/
‚îú‚îÄ‚îÄ queries.ts              # Server Action wrappers for data fetching
‚îú‚îÄ‚îÄ actions.ts              # ALL Server Actions for mutations (create/update/delete)
‚îú‚îÄ‚îÄ page.tsx               # Server Component (initial data load)
‚îî‚îÄ‚îÄ components/
    ‚îú‚îÄ‚îÄ EntitiesList.tsx   # Client Component using useQuery
    ‚îî‚îÄ‚îÄ CreateEntityForm.tsx # Client Component using useActionState

hooks/
‚îú‚îÄ‚îÄ queries/
‚îÇ   ‚îî‚îÄ‚îÄ entities/
‚îÇ       ‚îú‚îÄ‚îÄ getEntities.tsx      # useQuery hook
‚îÇ       ‚îî‚îÄ‚îÄ getEntityById.tsx    # useQuery hook
‚îî‚îÄ‚îÄ mutations/
    ‚îî‚îÄ‚îÄ entities.tsx             # useMutation hooks

services/
‚îî‚îÄ‚îÄ entities/
    ‚îú‚îÄ‚îÄ types.ts
    ‚îú‚îÄ‚îÄ transformers.ts
    ‚îú‚îÄ‚îÄ getEntities.ts           # Service function (uses Supabase server client)
    ‚îú‚îÄ‚îÄ createEntity.ts
    ‚îî‚îÄ‚îÄ index.ts
```

**Naming Conventions:**

- `queries.ts`: Server Action wrappers for READ operations (co-located with feature)
- `actions.ts`: **ALL** Server Actions for WRITE operations - create, update, delete (co-located with feature)
- `useGetX`: TanStack Query hooks in `hooks/queries/`
- `useXMutation`: TanStack Query mutation hooks in `hooks/mutations/`
- `XAction`: Server Action functions (suffixed with "Action")

**‚ö†Ô∏è CRITICAL: Single actions.ts File Per Feature**

**NEVER** create separate files like `delete-actions.ts`, `update-actions.ts`, etc.

**‚ùå WRONG:**

```
app/admin/entities/
‚îú‚îÄ‚îÄ actions.ts          # Only create actions
‚îú‚îÄ‚îÄ delete-actions.ts   # ‚ùå NO! Causes fragmentation
‚îî‚îÄ‚îÄ update-actions.ts   # ‚ùå NO! Causes fragmentation
```

**‚úÖ CORRECT:**

```
app/admin/entities/
‚îî‚îÄ‚îÄ actions.ts          # ALL mutations: create, update, delete
```

**Example of consolidated actions.ts:**

```typescript
'use server'

import { revalidatePath } from 'next/cache'

import { createEntity, updateEntity, deleteEntity } from '@/services/entities'

export async function createEntityAction(prevState, payload) {
  // ... create logic
}

export async function updateEntityAction(id, data) {
  // ... update logic
}

export async function deleteEntityAction(id) {
  // ... delete logic
}
```

**Benefits of single file:**

- All domain actions in one place
- Easier to maintain and find
- Consistent imports across codebase
- Shared type definitions
- Better code organization

## ‚ö†Ô∏è Common Pitfalls:

### Missing `revalidatePath`

**Problem:** Table doesn't refresh after create/edit, requiring manual page reload.

**Solution:** Always include `revalidatePath` in Server Actions:

```typescript
// ‚ùå BAD: No revalidation = slow/no refresh
export async function createEntityAction(...) {
  const result = await createEntity(data)
  if (result.error) return { success: false, errors: ... }

  return { success: true }  // UI won't update!
}

// ‚úÖ GOOD: Immediate refresh
export async function createEntityAction(...) {
  const result = await createEntity(data)
  if (result.error) return { success: false, errors: ... }

  revalidatePath('/admin/entities')  // ‚ú® Refreshes data immediately
  return { success: true }
}

// ‚úÖ GOOD: Multiple paths (for detail + list pages)
export async function updateEntityAction(...) {
  const result = await updateEntity(id, data)
  if (result.error) return { success: false, errors: ... }

  revalidatePath('/admin/entities')      // List page
  revalidatePath(`/admin/entities/${id}`) // Detail page
  return { success: true }
}
```

### Using Direct Service Calls Instead of Actions

**Problem:** Using `router.refresh()` or manual invalidation instead of Server Actions.

**Solution:** Refactor to use Server Actions with `revalidatePath`:

```typescript
// ‚ùå BAD: Client-side service call (old pattern)
const handleSubmit = async (data) => {
  const result = await updateEntity(id, data)
  if (result.error) {
    /* ... */
  }
  router.push('/admin/entities')
  router.refresh() // May not refresh properly
}

// ‚úÖ GOOD: Server Action with revalidatePath
const [formState, formAction, pending] = useActionState(updateEntityAction, {
  success: false
})
// Server Action handles revalidation automatically
```

### Calling Services Directly from Client Components

**Problem:** Attempting to import and call server-only services from Client Components.

**Error:**

```
Error: x You're importing a component that needs "next/headers".
That only works in a Server Component which is not supported in the pages/ directory.

Import trace:
./src/lib/supabase/server.ts
./src/services/entities/getEntities.ts
./src/hooks/queries/entities/getEntities.tsx  ‚Üê Client Component!
./src/app/admin/entities/components/EntitiesList.tsx
```

**Solution:** Always use Server Action wrappers (`queries.ts`) for data fetching:

```typescript
// ‚ùå BAD: Direct service import in Client Component
'use client'
import { getEntities } from '@/services/entities' // ‚ùå Error!

export function useGetEntities() {
  return useQuery({
    queryFn: () => getEntities() // ‚ùå Breaks at build time
  })
}

// ‚úÖ GOOD: Server Action wrapper
// app/admin/entities/queries.ts
;('use server')
export async function getEntitiesAction(params?: GetEntitiesParams) {
  return await getEntities(params) // ‚úÖ Server-side execution
}

// hooks/queries/entities/getEntities.tsx
;('use client')
import { getEntitiesAction } from '@/app/admin/entities/queries'

export function useGetEntities() {
  return useQuery({
    queryFn: () => getEntitiesAction() // ‚úÖ Works!
  })
}
```

**Why This Happens:**

- Services use `createClient()` from `@/lib/supabase/server`
- This function imports `next/headers` (cookies)
- `next/headers` can only be used in Server Components/Actions
- Client Components cannot import server-only modules
- Server Actions bridge the client-server boundary

**GOAL:** Consistency where possible, flexibility where necessary.
